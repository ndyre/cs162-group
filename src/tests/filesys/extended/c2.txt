Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ 
functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache.
 For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ f
 ollowing test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by
  ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache.
   Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to 
   ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, 
   ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially
    again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. T
    est your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same 
    ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter 
    and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least
     â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) 
     ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. 
     The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 
     128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability
      ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them 
      ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks)
       to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to
        ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ 
        exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. 
        Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. 
        ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a 
        ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. 
        You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does
         â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. 
         If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property,
          then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” 
          You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache
           features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific
            implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test
             ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» 
             the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are 
             ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– t
             he ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ 
             is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing
              ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases 
              that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s
               project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’†
                finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ»
                 they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ”
                  in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ 
                  should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜
                   filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚
                    run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the 
                    filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests,
                     ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to
                      interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since 
                      buffer cache information and block device ğŸ“±ğŸ“± statistics 
                      are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you 
                      ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support 
                      ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create 
                      ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files
                       ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): 
                       lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic
                        ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both 
                        user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` 
                        Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c 
                        Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep
                         in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: 
                         ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of
                          the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user 
                          library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ 
                          access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs 
                          do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented.
                           User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ…
                            a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos 
                            starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device 
                            is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’°
                             printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª 
                             filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. 
                             â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ 
                             the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, 
                             ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜
                              msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck 
                              ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ 
                              is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of 
                              the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with 
                              â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through 
                              ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. 
                              Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined
                               in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out
                                ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» 
                                driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ 
                                Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended 
                                test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ k
                                ernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, 
                                then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball a
                                nd ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script
                                 checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the c
                                 orrect âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘
                                  do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ 
                                  does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this
                                   ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.Pintos already âœ” contains a test ğŸ‘©ğŸ‘© suite for ğŸ”œâ˜¯ file â—â¡ system ğŸ¤£ functionalities, but ğŸ‘¹ğŸ‘ it does not ğŸ™…ğŸš« cover the ğŸ—ğŸ† buffer cache. For ğŸ†ğŸ‘… this project, â¬… you ğŸ‘ˆ must implement two ğŸ’ğŸ’ of ğŸ³ the ğŸ˜«ğŸ™Œ following test cases: ğŸ’¼ğŸ’¼ Test ğŸ’» your ğŸ‘ƒ buffer cacheâ€™s effectiveness by ğŸ‘€ğŸ­ measuring its cache hit rate. First, ğŸ˜Šâ˜ reset the ğŸ‘ buffer cache. Next, â©ğŸ“… open a ğŸ‘‰â° file â— and ğŸ‘ğŸ’¦ read ğŸ“–ğŸ“˜ it sequentially, to ğŸ¤£ğŸ’¦ determine the ğŸ˜ğŸ‘ cache hit rate ğŸ¤— for a cold â„ cache. Then, ğŸ˜‚ close ğŸ˜ğŸš« it, ğŸ˜¡ re-open ğŸ‘‰ it, and ğŸ‘ğŸ¥œ read ğŸ“–ğŸ‘ it ğŸ¸ğŸ”„ sequentially again, to ğŸ’¦ make ğŸ– sure that ğŸ‘¨ the ğŸ“… cache hit ğŸ” rate improves. Test your ğŸ’¸ buffer cacheâ€™s ability to ğŸ˜‹ğŸ”­ coalesce writes to ğŸ—£ğŸ’¦ the same ğŸ’©ğŸ¤¢ sector. Each ğŸ‘‹ block ğŸš«ğŸ¥œ device ğŸ’»ğŸ“± keeps a ğŸ‘ŒğŸ˜ read_cnt counter and a write_cnt ğŸ“âœ counter. Write âœ a large ğŸ”ğŸ¯ large file â¡ at ğŸ˜´ least â—ğŸ˜­ 64 ğŸ‘ºğŸ‘» KiB (i.e. twice âœŒ the ğŸ‘‰ğŸ» maximum allowed buffer cache size) ğŸ’ªğŸ˜« byte-by-byte. Then, ğŸ˜ğŸ˜© read ğŸ“–ğŸ‘ it âœ‹ğŸ‘ in ğŸ‘‰ğŸ‘ byte-by-byte. The total ğŸ‘Œ number of device ğŸ’»ğŸ“± writes âœ’ should ğŸ¤” be on the âœˆ order of 128 since ğŸ‘¨ğŸ’¦ 64 ğŸ‘º KiB is ğŸ’¦ 128 blocks. Test your ğŸ˜ buffer cacheâ€™s ability ğŸ‘‰ to ğŸ–‡ write ğŸ“ full ğŸ‘ŒğŸˆµ blocks to disk without ğŸš«ğŸ˜– reading ğŸ“—ğŸ‘€ them ğŸ˜ğŸ˜‘ first. If you are, for example, ğŸ”¥ writing ğŸ–‹ 100 ğŸ’¯ KiB (200 blocks) to ğŸ˜¯ğŸ’¦ a file, â—â¡ your buffer cache should perform ğŸ­ğŸ‘Œ 200 calls ğŸ“ to ğŸ˜˜ğŸ’¦ block_write, ğŸ‘ğŸ”® but ğŸ¤” 0 ğŸ˜Šâ• calls to block_read since ğŸ‘¨ğŸ’¦ exactly 200 blocks worth ğŸŒğŸŒ of data are ğŸ“²â“ being written. Read operations on ğŸ”› inode metadata are ğŸ‘ğŸ˜ still ğŸ˜» acceptable. ğŸ˜•ğŸ˜• As mentioned earlier, each ğŸ‘ğŸ‘‹ block device ğŸ’»ğŸ’» keeps a ğŸ‘ŒğŸ† read_cnt ğŸ‘ğŸ‘ counter and ğŸğŸ‘ a write_cnt âœâœ counter. You ğŸ•¯ can ğŸ’¦ use this ğŸ‘Œ to ğŸ…± verify that your ğŸ†ğŸ‘‰ buffer cache does â“ğŸ‹ not ğŸ‘ğŸ™… introduce unnecessary block ğŸ’¦ğŸ˜› reads. If ğŸ‘ your ğŸ’¦ buffer cache does ğŸ˜ˆğŸ˜³ not ğŸ™…ğŸ¼ have âœŠ this â“ğŸ˜… property, then ğŸ˜‚ implement the ğŸ˜ğŸŒ other âœ‰ğŸ‘³ two options listed above. ğŸ” You ğŸ‘‰ should focus on ğŸ¤ºâ¡ writing tests ğŸ’¯ for ğŸ™ƒğŸ† general â™‚ buffer cache features, rather â˜‘â˜‘ than writing âœğŸ–‹ tests ğŸ’¯ğŸ’¯ for â™¿ğŸ’˜ your specific implementation of ğŸ’¦ the buffer cache. You should ğŸ’˜ write your test ğŸ‘© cases ğŸ’¼ğŸ’¼ with ğŸ‘ a ğŸ‘ŒğŸ’° minimal set of ğŸ™ğŸ‘¯ assumptions about ğŸ» the ğŸŒŸğŸ¥– underlying buffer cache implementation, but ğŸ˜¤ you ğŸ¾ğŸ˜˜ are ğŸ‘Š permitted to ğŸ’¦ğŸ˜… make as many basic ğŸŒ‘ assumptions about ğŸ’¦ğŸ¤– the ğŸ‘ğŸ‘ buffer cache as ğŸ’° you ğŸ‘ˆ need âœ… to, ğŸŒˆğŸ…± since ğŸ‘¨ğŸ‘¨ it ğŸ’“ is ğŸ˜—ğŸ”¥ very ğŸ“ˆ difficult to write buffer cache tests ğŸ’¯ without doing ğŸƒ so. ğŸ’¯ Use your ğŸ» best ğŸ˜» judgement and create ğŸ“² test ğŸ˜¬ cases that could potentially be ğŸğŸ adapted to â™‚ a different â†”ğŸ¼ groupâ€™s project without ğŸ’¯âŒ rewriting the whole ğŸ’¦ thing. Once ğŸ’¯ you ğŸ’† finish writing your ğŸ˜ğŸ‘ test cases, ğŸ’¼ğŸ’¼ make ğŸ– sure ğŸ‘‰âœ” that ğŸ» they ğŸ¼ğŸ˜‚ get ğŸ’° executed when ğŸ•›ğŸ‘ you ğŸ¾ğŸ» run ğŸ˜‚ make âœŠ check âœ”âœ” in ğŸ‘†ğŸ™ˆ the filesys/ directory. Implementation details You ğŸ‘‰ğŸ˜¥ should ğŸ˜‘ add your ğŸ»ğŸ‘µ two ğŸ„âœŒ test ğŸ’»ğŸ˜¬ cases ğŸ’¼ğŸ’¼ to ğŸ’¦â˜ƒ the ğŸ‘‰ğŸ˜ filesys/extended test suite, which is ğŸ”¥ğŸ˜² included when you ğŸ˜§ğŸ˜‚ run ğŸƒğŸƒ make âœ‹ check âœ” from the filesys directory. All of the filesys and ğŸ™ userprog tests ğŸ’¯ğŸ’¯ are â“ğŸ™ â€œuser programâ€ tests, ğŸ’¯ğŸ’¯ which means ğŸ¤”ğŸ˜ that ğŸ‘€ğŸ˜¯ they ğŸ¼ are ğŸ’° only â˜ğŸ‘ allowed to interact with ğŸ’¦ the kernel via ğŸ’°ğŸ’° system calls. ğŸ‘ Since buffer cache information and block device ğŸ“±ğŸ“± statistics are ğŸ˜ NOT â™‚ currently exposed to user ğŸ•´ğŸ•´ programs, ğŸ’¸ğŸ¤· you ğŸ‘‰ must ğŸ’¯ğŸ™‹ create ğŸ“²ğŸ“² new system ğŸ»ğŸ» calls ğŸ‘ to support ğŸ‹ğŸ—½ your two new buffer cache tests. You ğŸ‘‰ can ğŸ”«ğŸ’° create ğŸ“² new ğŸ— system ğŸ» calls ğŸ‘ğŸ“ by ğŸšŸ modifying these ğŸ˜±ğŸ­ files ğŸ“ğŸ“ (and ğŸ—£ğŸ˜‰ their associated ğŸ™ header ğŸ¤¦ğŸ¤¦ files): lib/syscall-nr.h Defines the ğŸ’°ğŸ˜¹ syscall numbers and symbolic ğŸ¤˜ğŸ”£ constants. This âš ğŸ» file ğŸ“â¡ is ğŸ˜³ used ğŸ˜ğŸšŸ by ğŸ˜ˆğŸšŸ both user programs ğŸ¼ and the ğŸ‘€ kernel. ` lib/user/syscall.c` Syscall functions for user ğŸ’ªğŸ’ª programs. userprog/syscall.c Syscall handler implementations. Some ğŸ‘†ğŸ’¦ things to ğŸ‘‰ğŸ˜› keep in mind ğŸ˜²ğŸ˜ while ğŸ¤”ğŸ™Œ writing ğŸ–‹ your ğŸ‘ğŸ‘ˆ test cases: ğŸ’¼ User programs have access to ğŸ’µ a ğŸ‘ŒğŸ’° limited subset of the ğŸ…± C standard library. You can â— find the ğŸ…ğŸ‘¶ user library in lib/. User ğŸ’ª programs cannot â›”â›” directly â¡ access ğŸšª variables in ğŸš­ the ğŸ‘ kernel. User ğŸ’ªğŸ’ª programs do âš  not have âš  access ğŸ”–ğŸ”– to malloc, since ğŸ’¦ brk and sbrk are ğŸ”¢ğŸ’¯ not implemented. User ğŸ¤– programs ğŸ¼â™‚ also have ğŸ˜‘ğŸ…± a limited stack ğŸ“š size. If you ğŸ˜˜ğŸ˜€ need âœ… a ğŸ‰ğŸ‘Œ large ğŸ”ğŸ” buffer, make ğŸ»ğŸ‘ it a ğŸ‘ static global variable. Pintos starts ğŸâ†” with ğŸ’° 4MB of memory ğŸ’¾ğŸ’­ and ğŸ’°â• the file system block ğŸ”«ğŸ¤– device is ğŸŒˆ 2MB by ğŸ‘¨ default. Donâ€™t use data structures or ğŸ™… files ğŸ“ğŸ“ that exceed these ğŸ¥œ sizes. Your ğŸ’¯ğŸ‘‰ tests ğŸ’¯ğŸ’¯ should ğŸ¤” use ğŸ® msg() instead of ğŸ’° printf() (they ğŸ‘©ğŸ˜ˆ have ğŸ˜‚ğŸ‘€ the ğŸ‘½ğŸ‘ same ğŸ˜‚ğŸ…± function signature). Adding file system tests to ğŸ‘€ Pintos You ğŸ‘†ğŸ† can ğŸš« add ğŸ‘ˆ new test ğŸ’»ğŸ˜¬ cases to the ğŸ’ª filesys/extended suite by ğŸ˜ˆ modifying these ğŸ’¦ files ğŸ“ (all inside tests/filesys/extended): ğŸ’¯ Make.tests Entry point â¬† for ğŸ‘ğŸ† the ğŸ’°ğŸ„ filesys/extended test ğŸ˜¬ğŸ‘© suite. You ğŸ¾ğŸ¶ need to ğŸ’¦ add ğŸ‘ˆğŸ‘ˆ the name ğŸ¤” of your ğŸ‘ğŸ˜© test to ğŸ“ƒ the raw_tests variable, in order ğŸ¤œğŸ for âŒ› the ğŸ‘ğŸŒŠ test ğŸ‘© suite to ğŸ˜† find ğŸ‘€ğŸ˜± it. â˜ ğŸ’¯ my-test-1.c ğŸ…±ğŸ˜ This â¬‡ğŸ‘ˆ is ğŸ”¥ the ğŸ‘„ğŸ’° test code ğŸ˜²ğŸ˜² for your ğŸ…± test ğŸ’» (you are ğŸ¤“ free to ğŸ—ğŸ’¦ use ğŸ‘ whatever ğŸ’ name â™‚ you ğŸ˜ wish, â€œmy-test-1â€ ğŸ‘¨â­ is ğŸ˜¬ğŸ† just ğŸ•› an example). ğŸ”¥ Your test should ğŸ˜• define a function called test_main, ğŸ’»ğŸ’» which contains a ğŸ‘Œ user-level program. This ğŸ’¦ğŸ‘ˆ is ğŸ’¦ the ğŸ™ğŸ’‰ main body â™€ of your â™€ test ğŸ˜¬ case, ğŸ‘ŒğŸ‘… which ğŸ¥™ğŸ‘Œ should ğŸ’˜ make ğŸ’° syscalls and ğŸ‘ğŸ’° print ğŸ““ output. Use ğŸ˜ğŸ˜‚ the ğŸ˜ msg() function instead ğŸ‘ of ğŸ‘©ğŸ’¦ printf. my-test-1.ck ğŸ‘¦ Every ğŸ¼ğŸ˜¬ test ğŸ‘©ğŸ‘© needs ğŸ’ªâ¬† a .ck ğŸ†ğŸ† file, â— which ğŸ‘ is ğŸ™€ğŸ’¦ a Perl script that ğŸ…ğŸ’µ checks ğŸ“šğŸ“š the ğŸ‘€ğŸ˜ƒ output of the ğŸ˜ğŸ½ test ğŸ˜¬ program. If ğŸ…± you ğŸ˜˜ are â™€ğŸ”„ not familiar ğŸ‘© with â™ ğŸ¤ Perl, ğŸ˜ğŸ¼ donâ€™t ğŸš« worry! â™‚ You can ğŸ”«ğŸ¤” probably ğŸ² get through ğŸ˜© this â“ğŸ”¥ part ğŸ¤ğŸ–• with ğŸ‘ˆğŸ˜« some ğŸ–¤â™‚ educated ğŸ—¿ guessing. Your check script should ğŸ’˜ğŸ‘ use the subroutines that ğŸ˜â¡ are defined in tests/tests.pm. ğŸ’¯ At ğŸ‘’ the ğŸ˜ˆ end, â›”ğŸ”œ call ğŸ“± pass to ğŸ‘ print out ğŸ‘¿ğŸ’¯ the âœˆğŸ’¬ â€œPASSâ€ ğŸ’¯ message, ğŸ“© which tells the ğŸ˜ğŸ“– Pintos test ğŸ’» driver that ğŸ‘‰ your ğŸ˜» test ğŸ‘© passed. â©â© my-test-1-persistence.ck ğŸ’ªğŸ¤ Pintos expects a second ğŸ…¾ğŸ…± .ck ğŸ† file â—ğŸ“ for ğŸ¼ every ğŸ‘ğŸ‘ filesys/extended test ğŸ’»ğŸ’» case. ğŸ’¦ After each ğŸ‘ğŸ‘ test case ğŸ‘ŒğŸ‘… is ğŸ™ŒğŸ… run, ğŸƒ the ğŸ‘ğŸšŸ kernel is ğŸ…± rebooted using ğŸ“¤ğŸ¤³ the same ğŸ˜‚ file ğŸ“‚ system disk image, then ğŸ˜®ğŸ˜® Pintos saves the ğŸ‘ğŸš® entire ğŸ™‹ file â— system to a ğŸš¼ğŸ‘Œ tarball and ğŸ‘ exports it ğŸ’¯â— to the ğŸ˜ host ğŸ‘¨ğŸ« machine. The *-persistence.ck script checks âœ” that â˜  the ğŸ° tarball of ğŸš‹ğŸ’¦ the ğŸ‘½ file system ğŸŒŒ contains the correct âœ… structure and ğŸ—£ğŸ‘ contents. You ğŸ˜‚âŒ do ğŸ‘… not ğŸ™…â›” need ğŸ“²ğŸ˜© to ğŸ‘ do ğŸ˜‚ any ğŸ…±ğŸ˜± checking in ğŸŒ this ğŸ˜‚ file, ğŸ“‚ if ğŸ¤¥ğŸ¤¥ your test case ğŸ’¯ does not require it. However, ğŸ– you ğŸ˜¤ğŸ© should ğŸ¤” call pass â¬†ğŸ›‚ in this ğŸ‘€ğŸ“ file â¡ğŸ“‚ anyway, to ğŸ’¦ satisfy ğŸ˜‹ the ğŸ‘ğŸ¾ Pintos testing framework.